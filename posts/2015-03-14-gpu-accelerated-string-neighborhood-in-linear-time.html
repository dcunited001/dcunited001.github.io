<!doctype html>


<!--[if lt IE 7 ]><html itemscope itemtype="http://schema.org/Article" id="ie6" class="ie ie-old" lang="en-US"><![endif]-->
<!--[if IE 7 ]>   <html itemscope itemtype="http://schema.org/Article" id="ie7" class="ie ie-old" lang="en-US"><![endif]-->
<!--[if IE 8 ]>   <html itemscope itemtype="http://schema.org/Article" id="ie8" class="ie ie-old" lang="en-US"><![endif]-->
<!--[if IE 9 ]>   <html itemscope itemtype="http://schema.org/Article" id="ie9" class="ie" lang="en-US"><![endif]-->
<!--[if gt IE 9]><!--><html itemscope itemtype="http://schema.org/Article" lang="en-US"><!--<![endif]-->
<head>



    <!-- Meta -->
    <meta charset="utf-8">

    <title>&#x2295; GPU Accelerated Nucleotide Neighborhood in Linear Time ♥ te.xel.io</title>
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
    <meta content="yes" name="apple-mobile-web-app-capable">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <!-- RSS -->
    <link rel="alternate" type="application/rss+xml" title="te.xel.io ♥ " href="/feed.xml">
    <link rel="alternate" type="application/atom+xml" title="te.xel.io ♥ " href="/atom.xml">

    <!-- Favicons -->
    <link rel="shortcut icon" sizes="16x16 24x24 32x32 48x48 64x64 96x96" href="/favicon.ico">
    <link rel="apple-touch-icon" sizes="57x57" href="/img/favicons/favicon-57.png">
    <link rel="apple-touch-icon-precomposed" sizes="57x57" href="/img/favicons/favicon-57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="/img/favicons/favicon-60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/img/favicons/favicon-72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/img/favicons/favicon-76.png">
    <link rel="apple-touch-icon" sizes="96x96" href="/img/favicons/favicon-96.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/img/favicons/favicon-114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/img/favicons/favicon-120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/img/favicons/favicon-144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/img/favicons/favicon-152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/img/favicons/favicon-180.png">
    <link rel="apple-touch-icon" sizes="192x192" href="/img/favicons/favicon-192.png">
    <meta name="application-name" content="te.xel.io ♥ ">
    <meta name="msapplication-TileImage" content="/img/favicons/favicon-144.png">
    <meta name="msapplication-TileColor" content="#ffffff">

    <!-- Fonts -->
    <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Roboto+Condensed:300,300italic,400,400italic,700,700italic|Oswald:300,400,700">
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css">

    <!-- Styles -->
    <link rel="stylesheet" href="/css/style.css">
    <!--[if lt IE 9]>
        <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.2/html5shiv.min.js"></script>
        <script src="/js/respond.min.js"></script>
    <![endif]-->
</head>
  <body class="">

    <!-- ganalytics -->
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-49910074-1', 'xel.io');
      ga('send', 'pageview');

      var scrollDepthConfig = {}
      ga('require', 'scrollDepthTracker', '/js/scroll-depth-tracker.js', scrollDepthConfig);

      /* scrollDepthTracker defaults
      action : 'Pageview End',
      beacon : true,
      category : 'Page',
      debug : false,
      delay : true,
      labelNoScroll : 'Did Not Scroll',
      labelScroll : 'Did Scroll',
      sampleRate : 100,
      scrollThreshold : 10,
      setPage : true,
      timeout : 300,
      timeThreshold : 15,
      metric : null,
      maxTimeOnPage : 30
      */
    </script>

    <nav id="main-navbar" class="navbar navbar-inverse navbar-fixed-top">
        <div class="container-fluid">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="/">
                  <span class="navbar-lambda">λ</span>&nbsp;
                  <i class="fa fa-heart"></i>&nbsp;
                  te.xel.io
                </a>
            </div>
            <div id="navbar" class="navbar-collapse collapse">
                <ul class="nav navbar-nav navbar-right">
                    
                        <li><a href="/graphics">3D & Math</a></li>
                    
                        <li><a href="/writing">Writing</a></li>
                    
                        <li><a href="/projects">Projects</a></li>
                    
                        <li><a href="/quotes">Quotes</a></li>
                    
                        <li><a href="/about">About</a></li>
                    
                        <li><a href="/tags">Tags</a></li>
                    
                    <li class="navbar-social">
                      <a href="https://github.com/dcunited001"><i class="fa fa-lg fa-github"></i></a>
                      <a href="https://youtube.com/dcunited001"><i class="fa fa-lg fa-youtube"></i></a>
                      <a href="https://twitter.com/dcunit3d"><i class="fa fa-lg fa-twitter"></i></a>
                      <a href="https://linkedin.com/in/dcunit3d"><i class="fa fa-lg fa-linkedin"></i></a>
                      <a href="https://angel.co/dcunit3d"><i class="fa fa-lg fa-angellist"></i></a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>




<div class="title-group">
  

  <h1 class="special">
    <span>
      
      &#x2295; GPU Accelerated Nucleotide Neighborhood in Linear Time
      
    </span>
  </h1>

  
  <aside>
    03.14.15
    
    &middot;
    
    <span>Blog</span>
    
    
  </aside>
  

  <aside>
    <span class="title-subglyph">
      &nbsp;(&nbsp;λ&nbsp;<i class="fa fa-heart"></i>
      <a href="#" id="btn-subglyph" onclick="toggleSubglyph()" data-toggle="tooltip" title="Click Me To Escape Index-Based Censorship">§µßƍŁ¥þĦ</a>
      )&nbsp;
    </span>
  </aside>
</div>


<div class="container">

  <article>
    <section class="article-content">
      <div class="row">
        <div class="col-md-10 col-md-offset-1">
          <h3 id="happy-pi-day">Happy Pi Day!</h3>

<p><img src="/img/posts/2015-03-14-gpu-accelerated-string-neighborhood-in-linear-time/pi-digits.png" alt="Pi Digits" /></p>

<h4 id="heres-a-picture-visualizing-the-digits-in-pi">Here’s a picture visualizing the digits in Pi.</h4>

<p>Remember, there is nothing universal about a base-10 numbering system.
So, while this graph sure has some perdy colors in it, it’s mostly
meaningless.  But, that’s the beauty of irrational numbers: <em>il y a un
peu de je ne sais quoi</em>.</p>

<h4 id="but-hey-look-a-star">But hey! look a <em>STAR</em>!</h4>

<p><img src="/img/posts/2015-03-14-gpu-accelerated-string-neighborhood-in-linear-time/pi-digits-graph.png" alt="Pi Digits Graph" /></p>

<h4 id="this-one-visualizes-the-relationships-between-digits-in-pi">This one visualizes the relationships between digits in pi.</h4>

<p>Again, it’s a meaningless representation of the data since it’s
visualizing the base-10 numbering system.  The star shows up in the
picture because there are 10 digits and the artist chose to alternate
between light and dark!  If we did the same thing with a base 14
numbering system, you’d see a 7 pointed star…  Look at the colors
though!  The colors!</p>

<h3 id="back-to-the-bioinformatics-algorithms">Back to the Bioinformatics Algorithms</h3>

<p>These are the algorithms I’m most proud of implementing.  Sure,
<a href="https://github.com/dcunited001/bioclj">this code</a> is available on
github, but it’s written in Clojure, so it’s impossible for most
people to understand without some head-scratching.  In fact, it took
quite a bit of effort just for me to freshen up enough to write this
article.  And that, my friends, is security by obfuscation – which is
not a virtue for code or for much of anything, really.</p>

<p>I enjoy writing code in Clojure because Lisp forces you to write code
in a functional manner and therefore your code more closely resembles
the pure math you’re implementing.  I’ve been sending out this project
along with job applications, but I don’t think most people understand
what they’re looking at, which is unfortunate.  So, I’ve blogged about
it and I’ll send out this link instead.</p>

<p>I can’t imagine that someone else hasn’t thought of these ideas for
bioinformatics.  Sure, they involve some bitcrunching, but it’s really
not that complicated.  Specifically, here are the two algorithms in my
project that I’m referring to.</p>

<h4 id="x2605-constant-time-hamming-distancehttpsgithubcomdcunited001biocljblobmastersrcbiocljstringcljl122-implemented-specifically-for-strings-of-nucleotides"><a href="https://github.com/dcunited001/bioclj/blob/master/src/bioclj/string.clj#L122">★ Constant Time Hamming Distance</a> implemented specifically for strings of nucleotides.</h4>

<h4 id="x2605-neighbor-transformhttpsgithubcomdcunited001biocljblobmastersrcbiocljstringcljl227--basically-simultaneous-binary-addition-specifically-for-nucleotides"><a href="https://github.com/dcunited001/bioclj/blob/master/src/bioclj/string.clj#L227">★ Neighbor Transform</a>.  Basically, simultaneous binary addition, specifically for nucleotides.</h4>

<h3 id="bioinformatics-on-coursera">Bioinformatics on Coursera</h3>

<p>Back in November, I started taking this
<a href="https://www.coursera.org/course/bioinformatics2">Bioinformatics</a>
class on Coursera, taught by Pavel Pevzner and Phillip Compeau.  It
was one of the best classes I’ve taken on Coursera so far.  The
interactive text was very well built and organized.  I could progress
without needing to watch the videos, but those were a great resource
if I needed more detail in some sections.</p>

<p>Additionally, the course was just the right level of challenging: not
only did you have to write the code, but your submissions were
automatically graded with a five minute time limit.  And in
bioinformatics, ** * time is key! * ** So if you couldn’t write your
code to complete within that five minute time limit, you didn’t get
any credit for those solutions.  The problems were all great Computer
Science algorithms: motif enumeration, hamming distance and a good bit
of graph theory.</p>

<p>For their language of choice, most students went with Python, which is
expected for university students.  However, I solved the problems in
Clojure :) and this made things both easier and harder.  It was a bit
harder to rethink these problems to properly utilize recursion,
immutable data structures and other functional programming paradigms.</p>

<p>However, the consequences of doing so proved invaluable when my
solutions were a bit too slow.  Solution didn’t run within the time
limit?! Oh shit, better completely rewrite my solution to include
thread pools and …. wait, just kidding!  <strong>r/fold</strong> and <strong>pmap</strong>
that shit! LMAO.  Needz moar threadz?  No problem, I really just need
more cores!</p>

<h3 id="a-side-trek-into-supercomputing">A side trek into supercomputing</h3>

<p>And this, folks, is why the work that the great folks on HP’s team for
The Machine will absolutely revolutionize computing in the next five
years.  It completely changes the software paradigm for
supercomputing.  Computing is going to start moving very fast: much
faster than we anticipate!  Because of revolutions in hardware that
shift the paradigm of software, that means Moore’s Law – while still
technically applicable until quantum/nano computing – no longer
determines the limits of computing.</p>

<p><img src="/img/posts/2015-03-14-gpu-accelerated-string-neighborhood-in-linear-time/all-the-shares.jpg" alt="Purchase All the Shares" /></p>

<h4 id="because-hp-has-patented-all-the-things-their-stock-is-going-to-be-a-good-long-term-buy-">Because HP has patented all the things, their stock is going to be a good long term buy! =$</h4>

<p>HP has patented several key technologies in it’s development of The
Machine.  Excluding the development of competing technologies (which
isn’t very likely) or the complete collapse of the global economy, i’m
extremely confident that HP is a good long term buy.  As to how good,
I can’t say.  I would place another large bet on HP’s decision to
restructure being fairly dependent on the development of this new
technology =] =]</p>

<h3 id="watch-this-video-for-a-7-minute-overview-of-the-machine">Watch this Video for a 7 Minute Overview of <em>The Machine</em></h3>

<iframe width="560" height="315" src="https://www.youtube.com/embed/jcmsby8jDKE" frameborder="0" allowfullscreen=""></iframe>

<blockquote>
  <p>Note: HP is
<a href="http://www.reuters.com/article/2014/10/06/us-hp-restructuring-idUSKCN0HV0U720141006">restructuring itself</a>
into two public companies: one to sell PC’s to consumers and the
other to sell servers and networking gear.  Make sure you purchase
the correct stock!</p>
</blockquote>

<h3 id="fiber-to-the-dome">Fiber to the Dome</h3>

<p><em>One</em> of their game-changing technologies is photonics.  Having
phonotics integrated into the bus means that CPU’s are no longer
physically bound to their memory.  That’s an oversimplified
explanation of things.  However, as it is now, software developers for
computationally intensive projects have to include lots of code just
to push data where it’s needed.  But photonics means that CPU’s can
access a nearly unlimited supply of memory, instantaneously.</p>

<p><img src="/img/posts/2015-03-14-gpu-accelerated-string-neighborhood-in-linear-time/petabytes.jpg" alt="Petabytes of RAM" /></p>

<p>This means supercomputers and the software they run can begin to be
designed very differently: you basically just need to add more cores,
since all of them can instantly access Petabytes of RAM.  Managing
workloads becomes much easier.  Any programs which utilize dynamic
programming to store result sets become more efficient.  For example,
in the Nucleotide Neighborhood algorithm I’m about to describe, you
can pre-calculate the result set of every Base Neighborhood for [k,d]
– really only for each k up to some specified max d, since [k,d] is
contained within [k,d+1].  And because your processors integrate with
as much RAM as you need without the overhead of workload management,
it becomes very easy to just throw more computational resources at
problems.</p>

<blockquote>
  <p>Please note: the statements above are venturing into areas where I
do not have enough knowledge. Therefore, I may have misspoken when I
said that this technology revolutionizes the design of
supercomputing. You might want to ask your fellow PhD.  However, I
know this is true to some degree. But, as to what degree, I’m not
sure.  I would need to learn more about heterogenous and distributed
computing to be certain.</p>

  <p>Gee, I wish there was a coursera class for Heterogenous Computing –
oh wait, there is.  I tried to take it once, but I was forced to get
a job and didn’t have the time.  Fortunately, I learned enough to
understand how linear algebra operations can be accelerated by the
GPU.  It really is fascinating stuff.</p>
</blockquote>

<p>Once you precalculate these result sets, they are available for other
programs to utilize them, assuming that you can provide enough shared
memory.  And since you only need to precalculate the Base Neighborhood
for each [k,d], this means if you load these base neighborhoods into
petabytes of RAM, you can instantly access these result sets, which
can be translated to the neighborhood for any [k,d].  This algorithm
can be accelerated with the application of one GPU accelerable
operation or one FPGA instruction to each string in the neighborhood.
The performance can also be further accelerated in other ways.</p>

<p>So why is this important?  Well for many categories of bioinformatics
problems, such as motif enumeration, calculating the neighborhoods
across each index in the dataset is the basic operation upon which
everything else builds.  So if you make that much faster, everything
else becomes faster too.  Complexity theory and what not.</p>

<h3 id="nucleotide-neighborhood-in-linear-time">Nucleotide Neighborhood in Linear Time</h3>

<p>So, linear time is a bit of a misnomer for two reasons:</p>

<h3 id="x2605-1-the-base-neighborhood-has-to-be-calculated-once-already">★ 1 The Base Neighborhood has to be calculated once already</h3>

<p>So you have to solve the problem in an expensive manner once, but
then, with a GPU, you can pretty much instantly generate the
neighborhood of any string of nucleotides.  The algorithm is linear,
it’s GPU-accelerable.  So instead of being O(N), it’s more like
O(N/1024), which is a significant improvement.</p>

<h3 id="x2605-2-its-linear-to-the--of-nucleotide-strings-in-the-neighborhood">★ 2 It’s Linear to the # of Nucleotide Strings in the Neighborhood</h3>

<p>Instead of being linear to ** <em>k</em> **, this algorithm is linear to the
number of strings in the neighborhood that you’re trying to find,
which is constant for any given [k,d].  It turns out that, for
nucleotide strings of length &lt;10, this algorithm isn’t that much
faster.  However, as you increase K and increase D, the performance
enhancements become more and more noticeable.</p>

<h3 id="how-is-this-possible-for-strings-of-nucleotides">How is this possible for strings of nucleotides?</h3>

<p>So normally, generating the string neighborhood is a very expensive
operation.  For example, Google uses this for autocorrect and
autocompletion, to automatically suggest words that you may have meant
to type.  This is a fairly expensive algorithm, but generating the
neighborhood for a string of a set of 4 characters is a special case
because these strings can easily be encoded into binary.  So, because
of this, there are a lot of binary hacks that are available to use.
It’s possible to do this for character sets that are not powers of 2,
but doing so is quite a bit more complicated.</p>

<h3 id="how-does-this-change-the-design-of-dependent-algorithms">How does this change the design of dependent algorithms?</h3>

<p>Since the generating the neighborhood is no longer a time constraint,
you can use dynamic programming to precalculate all the Base
Neighborhoods for [k,d] for <strong>[1 &lt;= k &lt;= 32]</strong> and for
<strong>[1 &lt;= d &lt;= 8]</strong>.  For most bioinformatics applications, you
shouldn’t need neighborhoods for values outside of those ranges.
Possibly for larger values of K, but having 128-bit or 256-bit
encoding would make that drastically easier because you would avoid
juggling 64-ints in arrays.  This is why there’s a need for chips and
hardware, specifically designed for these computing applications.</p>

<p>Therefore, you no longer have to juggle resources for computing
workloads and this overhead is eliminated.  With photonics and HP’s
Machine, each core can now access literally petabytes of RAM,
instantly.  There’s no need to calculate datasets specific to each
workload.  And this makes the software easier to develop as well.</p>

<h3 id="starting-with-an-improved-hamming-distance-algorithm">Starting with an improved Hamming Distance algorithm.</h3>

<p>So, since strings of nucleotides are essentially base-4 numbers, they
can easily be encoded into binary and stored in 64-bit integers.
Example Integers are below, encoded in base-2 and base-4, starting on
the left-hand side.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span></span><span class="n">acgtacgt</span><span class="o">.</span><span class="n">as_string</span> <span class="o">=</span> <span class="s2">&quot;ACGTACGT&quot;</span>
<span class="n">aaaacccc</span><span class="o">.</span><span class="n">as_string</span> <span class="o">=</span> <span class="s2">&quot;AAAACCCC&quot;</span>

<span class="c1"># A = 00, C = 01, G = 10, T = 11</span>
<span class="n">acgtacgt</span><span class="o">.</span><span class="n">as_base2</span> <span class="o">=</span> <span class="s2">&quot;0001101100011011&quot;</span>
<span class="n">aaaacccc</span><span class="o">.</span><span class="n">as_base2</span> <span class="o">=</span> <span class="s2">&quot;0000000001010101&quot;</span>

<span class="n">acgtacgt</span><span class="o">.</span><span class="n">as_base4</span> <span class="o">=</span> <span class="s2">&quot;01230123&quot;</span>
<span class="n">aaaacccc</span><span class="o">.</span><span class="n">as_base4</span> <span class="o">=</span> <span class="s2">&quot;00001111&quot;</span></code></pre></figure>

<p>For binary numbers, Hamming Distance is usually calculated by xor’ing
each input and counting the bits.  Fortunately, there is a CPU
instruction just for counting bits, as it turns out that this is an
incredibly important operation that is very fast in hardware.  For two
base-4 numbers, things are a bit more complicated.  But Hamming
Distance can still be reduced to a single operation – and a single
FPGA instruction.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span></span><span class="n">binary1</span> <span class="o">=</span> <span class="s2">&quot;00110011&quot;</span>
<span class="n">binary2</span> <span class="o">=</span> <span class="s2">&quot;01100011&quot;</span>
<span class="n">difbits</span> <span class="o">=</span> <span class="s2">&quot;01010000&quot;</span>

<span class="n">xor</span><span class="p">(</span><span class="n">binary1</span><span class="p">,</span> <span class="n">binary2</span><span class="p">)</span> <span class="o">=</span> <span class="s2">&quot;01010000&quot;</span>
<span class="n">countbits</span><span class="p">(</span><span class="s2">&quot;01010000&quot;</span><span class="p">)</span> <span class="o">=</span> <span class="mi">2</span>

<span class="c1"># therefore, the base2 hamming distance is 2</span>
<span class="c1">#   because there are two bits that differ between binary1 and binary2</span></code></pre></figure>

<p>Using base4 numbers encoded into 64-bit integers, things are a bit
more complicated.  We’re not just looking for the bits that are
different.  Instead, we’re looking for the number of 2-bit values that
differ.  We’ll need to shuffle the bits around to ensure that each
2-bit position is counted only once.</p>

<p>Here’s the algorithm to calculate the hamming distance between two
nucleotides A &amp; B of less than 32, encoded as 64-bit integers:</p>

<h4 id="x2605-nbsp-x--a-x2295-b">★   X = A ⊕ B</h4>

<h4 id="x2605-nbsp-y--x--2-bitshift-left">★   Y = X * 2 (bitshift left)</h4>

<h4 id="x2605-nbsp-z--10101010-magic-number">★   Z = 10101010… (magic number)</h4>

<h4 id="x2605-nbsp-w--y--z">★   W = Y &amp; Z</h4>

<h4 id="x2605-nbsp-g--w--x">★   G = W | X</h4>

<h4 id="x2605-nbsp-h--g--z">★   H = G &amp; Z</h4>

<h4 id="x2605-nbsp-hammingdistab--countbitsh">★   HammingDist(A,B) = countBits(H)</h4>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span></span><span class="o">+------------------+----------+----------+</span>
<span class="o">|</span> <span class="n">A</span> <span class="o">=</span> <span class="no">ACGTACGT</span>     <span class="o">|</span> <span class="mo">00011011</span> <span class="o">|</span> <span class="mo">00011011</span> <span class="o">|</span>
<span class="o">|</span> <span class="n">B</span> <span class="o">=</span> <span class="no">AAAACCCC</span>     <span class="o">|</span> <span class="mo">00000000</span> <span class="o">|</span> <span class="mo">01010101</span> <span class="o">|</span>
<span class="o">|</span> <span class="o">----------------</span> <span class="o">|</span> <span class="o">--------</span> <span class="o">|</span> <span class="o">--------</span> <span class="o">|</span>
<span class="o">|</span> <span class="n">X</span> <span class="o">=</span> <span class="n">A</span> <span class="n">xor</span> <span class="n">B</span>      <span class="o">|</span> <span class="mo">00011011</span> <span class="o">|</span> <span class="mo">01001110</span> <span class="o">|</span>
<span class="o">|</span> <span class="n">Y</span> <span class="o">=</span> <span class="n">X</span><span class="o">*</span><span class="mi">2</span> <span class="p">(</span><span class="no">BSL</span><span class="p">)</span>    <span class="o">|</span> <span class="mo">00110110</span> <span class="o">|</span> <span class="mi">10011100</span> <span class="o">|</span>
<span class="o">|</span> <span class="n">Z</span> <span class="o">=</span> <span class="no">Magic</span> <span class="c1">#      | 10101010 | 10101010 |</span>
<span class="o">|</span> <span class="o">----------------</span> <span class="o">|</span> <span class="o">--------</span> <span class="o">|</span> <span class="o">--------</span> <span class="o">|</span>
<span class="o">|</span> <span class="n">W</span> <span class="o">=</span> <span class="n">Y</span> <span class="o">&amp;</span> <span class="n">Z</span>        <span class="o">|</span> <span class="mo">00100010</span> <span class="o">|</span> <span class="mi">10001000</span> <span class="o">|</span>
<span class="o">|</span> <span class="n">X</span> <span class="o">=</span> <span class="n">A</span> <span class="n">xor</span> <span class="n">B</span>      <span class="o">|</span> <span class="mo">00011011</span> <span class="o">|</span> <span class="mo">01001110</span> <span class="o">|</span>
<span class="o">|</span> <span class="n">G</span> <span class="o">=</span> <span class="n">W</span> <span class="o">|</span> <span class="n">X</span>        <span class="o">|</span> <span class="mo">00111011</span> <span class="o">|</span> <span class="mi">11001110</span> <span class="o">|</span>
<span class="o">|</span> <span class="n">Z</span> <span class="o">=</span> <span class="no">Magic</span> <span class="c1">#      | 10101010 | 10101010 |</span>
<span class="o">|</span> <span class="n">H</span> <span class="o">=</span> <span class="n">G</span> <span class="o">&amp;</span> <span class="n">Z</span>        <span class="o">|</span> <span class="mo">00101010</span> <span class="o">|</span> <span class="mi">10001010</span> <span class="o">|</span>
<span class="o">|</span> <span class="o">----------------</span> <span class="o">|</span> <span class="o">--------</span> <span class="o">|</span> <span class="o">--------</span> <span class="o">|</span>
<span class="o">|</span> <span class="no">HammingDist</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">)</span> <span class="o">|</span> <span class="mi">3</span>        <span class="o">|</span> <span class="mi">3</span>        <span class="o">|</span>
<span class="o">+------------------+----------+----------+</span></code></pre></figure>

<h3 id="thats-just-hamming-distance-in-constant-time--who-cares">That’s just Hamming Distance in Constant Time.  Who cares?</h3>

<p>Well, because Hamming Distance is a kind of distance, certain rules
from Functional Analysis apply.  Unfortunately, because I’ve only
watched the first few videos in John Cagnol’s
<a href="https://www.coursera.org/course/functionalanalysis">Functional Analysis</a>
class, I can’t really describe which rules apply or which category of
distance/space that Hamming Distance falls under.</p>

<blockquote>
  <p>I wish Coursera had scholarships, lulz.  Then, I could get paidz to learnz this stuff.</p>
</blockquote>

<p>However, the important thing to note is that, for a nucleotide of any
length, it’s neighborhood for [k,d] is basically equivalent to the set
representing the neighborhood of the Base Nucleotide for [k,d], with a
function applied to each member of the set.  The Base Nucleotide is a
nucleotide of length K with it’s values set to zeros – all A’s – and
this Nucleotide’s neighborhood is the Base Neighborhood.</p>

<p>When you iterate this single transformation function across the Base
Neighborhood, you arrive at the neighborhood for another nucleotide.
This is because all relationships between these nucleotides are
preserved.  There are probably more patterns here that I’m not seeing
for lack of fully understanding the math.  For example, there may be
some more efficient means of discovering the members common between
two sets, which is another very important operation for Motif
Enumeration.</p>

<h3 id="the-neighbor-transform-algorithm">The Neighbor Transform Algorithm</h3>

<p>This algorithm basically performs 2-bit addition on a member of the
Base Neighborhood to arrive at a the member of a new neighborhood.
That’s all it takes.  One pseudo-addition operation.  What do I mean
be 2-bit addition?  I mean you literally add two nucleotides and wrap
the results every two bits.  I’m sure there’s a more official name for
this, but I don’t know what it is.</p>

<blockquote>
  <p>That’s really the biggest difference between someone who has an
academic education and someone who’s mostly self-educated and
autodidactic: one has a consistent set of vocabulary they use to
facilitate communication with other academics and the other
sometimes finds it hard to communicate and describe what are
essentially the same ideas.  Of course, being able to effectively
utilize a consistent set of vocabulary to quickly communicate
complicated ideas is incredibly useful.</p>
</blockquote>

<p>The most beneficial aspect of the Neighbor Transform is that the
algorithm doesn’t require intermediate data values.  In other words,
all operations of the Neighborhood Transform algorithm can proceed at
the same time.  All you have to do is coordinate the transformation of
each member of the set.  Therefore, it’s GPU accelerable, assuming you
have the original Base Neighborhood calculated.  This is a major
advantage!</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span></span><span class="o">+---------------------+------+-------------+</span>
<span class="o">|</span> <span class="no">Base</span> <span class="no">Nucleotide</span>     <span class="o">|</span> <span class="no">AAAA</span> <span class="o">|</span> <span class="mo">00</span> <span class="mo">00</span> <span class="mo">00</span> <span class="mo">00</span> <span class="o">|</span>
<span class="o">|</span> <span class="no">Target</span> <span class="no">Neighborhood</span> <span class="o">|</span> <span class="no">ACGT</span> <span class="o">|</span> <span class="mo">00</span> <span class="mo">01</span> <span class="mi">10</span> <span class="mi">11</span> <span class="o">|</span>
<span class="o">|</span> <span class="no">Nucleotide</span>          <span class="o">|</span> <span class="no">AAGA</span> <span class="o">|</span> <span class="mo">00</span> <span class="mo">00</span> <span class="mi">10</span> <span class="mo">00</span> <span class="o">|</span>
<span class="o">|</span> <span class="no">AAGA</span> <span class="o">~+</span> <span class="no">ACGT</span>        <span class="o">|</span> <span class="no">ACAT</span> <span class="o">|</span> <span class="mo">00</span> <span class="mo">01</span> <span class="mo">00</span> <span class="mi">11</span> <span class="o">|</span>
<span class="o">+---------------------+------+-------------+</span></code></pre></figure>

<h3 id="this-neighbor-transform-alg-is-also-applicable-to-amino-acid--codon-neighborhoods">This Neighbor Transform Alg is also Applicable to Amino Acid &amp; Codon Neighborhoods</h3>

<p>This bitcrunching algorithm was much more difficult to work out than
the binary addition.  At certain points, I wasn’t sure if it was
possible, but my gut told me I should keep trying.  This bitcrunching
algorithm is fairly simple because there are are 4 nucleotide values
to work with.  If this wasn’t a power of two, it’d still be possible,
but much more difficult and not simple at all.</p>

<p>It might work well with base64 numbers, to generate neighborhoods for
amino acids, etc – though these algorithms don’t take tRNA into
account!  Although, encoding base64 numbers into 64-bit integers
requires 6 bits per value, allowing simple neighbor transforms on up
to 10 values and leaving 4 bits for misc usage.  Defintely don’t want
to write code managing arrays of these 64-bit integers – YUCK!
Google probably got a few nerds to do it though LMAO.  If they did, I
feel for them!</p>

<p>If applied for proteins and codons, you’re better off running things
with 256-bit integers, so there’s probably a need for custom chips
used to parallel process bioinformatics data.  A sort of BPU – Bio
Processing Unit.  I have some ideas for this . . . but it looks like
there’s already people doing things with FPGA’s.  I don’t think FPGA’s
are optimized for parallel processing though.</p>

<h3 id="so-how-does-this-2-bit-addition-work">So, how does this 2-bit addition work?</h3>

<p>I’m sure it’s not wholy original, but I’m pretty proud of coming up
with this without having anyone tell me whether it was possible.  I
seem to be pretty good at that though.  I did this a lot in
Jamskating, by the way.  I specifically thought of variations which I
thought were impossible and worked to discover ways to make them
possible.  Maybe I was laughed at while I was pushing the boundaries
of Jamskating, but eventually everyone else caught up.</p>

<h4 id="x2605-nbsp-l--10101010-left-bit-magic-number">★   L = 10101010… (left bit magic number)</h4>

<h4 id="x2605-nbsp-r--01010101-right-bit-magic-number">★   R = 01010101… (right bit magic number)</h4>

<h4 id="x2605-nbsp-x--a--r--b--r-unchecked-addition">★   X = (A &amp; R) + (B &amp; R) (unchecked addition)</h4>

<h4 id="x2605-nbsp-y--a--l--b--l-unchecked-addition">★   Y = (A &amp; L) + (B &amp; L) (unchecked addition)</h4>

<h4 id="x2605-nbsp-z--x-x2295-y">★   Z = (X ⊕ Y)</h4>

<h4 id="x2605-nbsp-u--x--r">★   U = (X &amp; R)</h4>

<h4 id="x2605-nbsp-v--z--l">★   V = (Z &amp; L)</h4>

<h4 id="x2605-nbsp-w--u--v">★   W = (U | V)</h4>

<p><em>W is the simultaneous addition of 32 pairs of 2-bit integers inside
two 64-bit integers.</em> You can do the same thing for 3-bit integers,
4-bit integers, etc.  But it’s only the powers of two which end up
working nicely.  However, wouldn’t it be cool to have an algorithm
which generates functions for the simultaneous addition of X-bit
numbers? Well, it’s possible! <strong>And folks, that is the power of
functional programming and category theory!!</strong></p>

<h3 id="it-is-possible-to-apply-these-same-insights-to-levenshtein-neighborhoods-for-nucleotides">It is possible to apply these same insights to Levenshtein Neighborhoods for Nucleotides!</h3>

<p>It’s important to note that these insights carry over to levenshtein
neighborhoods, which are also deterministic and transformable.
However, doing so is much more complicated – yet, the performance
gains are even greater!  It also possible to come up with an analogous
parallelizable algorithm for transforming the base levenshtein
neighborhood into other levenschtein neighborhoods!  The benefits of
doing so are a dozen times greater.</p>

<p><img src="/img/posts/2015-03-14-gpu-accelerated-string-neighborhood-in-linear-time/morgan-freeman.png" alt="Morgan Freeman" /></p>

<h3 id="improvements-to-other-algorithms">Improvements to Other Algorithms</h3>

<p>I’ve got some ideas for some improvements, which I doubt are wholy
original.  But, who knows?  I also have some novel ideas about protein
folding algorithms =] =] I just need to learn more about searching
through spaces and optimizing energy for molecular structures.  And
more about molecular dynamics.  Yeh, that.</p>

<p>As I was researching GPU assisted Bioinformatics algorithms, I found
<a href="https://sites.google.com/site/trantuantubk/">Tuan Tu Tran</a>’s site and
papers.
<a href="https://sites.google.com/site/trantuantubk/phd-tuan-tu-tran.pdf">Here</a>
is his excellent paper on GPU assisted Bioinformatics Algorithms that
inspired me to dig a little deeper.  These and other interesting links
can also be can be found in the readme for my
<a href="https://github.com/dcunited001/bioclj">BioClj</a> github project page.</p>

        </div>
      </div>
    </section>

    <section class="comments">
      
<div id="disqus_thread"></div>
<script type="text/javascript">
  window.disqus_identifier="";
  window.disqus_url="https://te.xel.io//posts/2015-03-14-gpu-accelerated-string-neighborhood-in-linear-time.html";
  window.disqus_title="&#x2295; GPU Accelerated Nucleotide Neighborhood in Linear Time";
</script>
<script type="text/javascript" src="https://disqus.com/forums/te-xel-io/embed.js"></script>
<noscript><a href="https://te-xel-io.disqus.com/?url=ref">View the discussion thread.</a></noscript>


    </section>

  </article>

</div>

    <footer class="site-footer">
        <div class="container">
            <div class="row">
                <div class="col-md-12">
                  <p class="text-muted">
                    dconner.pro@gmail.com&nbsp; &copy; 2019
                    &nbsp;<a href="/feed.xml"><i class="fa fa-rss-square"></i></a>
                    &nbsp;<a href="/atom.xml"><i class="fa fa-rss"></i></a>
                  </p>
                </div>
            </div>
        </div>
    </footer>

    <!-- JavaScript -->
    <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
    <script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.5/js/bootstrap.min.js"></script>
    <script src="/js/tagcanvas.min.js" type="text/javascript"></script>
    <script src="/js/underscore.js"></script>

    

    <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
    <script src="/js/subglyph/subglyph.js" type="text/javascript"></script>

    <!-- load remotely -->
    <script src="http://te.xel.io/js/subglyph/subglyph-dictionary.js" type="text/javascript" charset="UTF-16"></script>

    <script>
      var btnSubglyph = $('#btn-subglyph');
      btnSubglyph.tooltip();

      subglyph = new Subglyph({
        dictionary: SUBGLYPH_DEFAULTS
      });

      toggleSubglyph = function() {
        var article = document.getElementsByTagName('article')[0];
        var newArticleHTML = subglyph.glyphIt(article);
        article.innerHTML = newArticleHTML;
      }
    </script>
    </body>
</html>

